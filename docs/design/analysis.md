# Analysis of change in design

- We want to break the card rules into pluggable effects, so we can add new card with specific use effect and draw effect (like the exploding kitten), which is according to the Open/Closed Principle. Currently, GameUI contains a massive switch statement that hardcodes behavior for every card type. When adding new cards, we must modify this existing code. Additionally, the card effect logic is entirely embedded in GameUI, which demonstrates Single Responsibility Principle violation - the GameUI module takes responsibility for both UI interaction and card effect behavior definition. This tight coupling makes the system rigid, hard to test (cannot test card effects without UI), and difficult to extend. To solve this, we introduce CardEffect interface for card use effects (when player plays the card) and DrawTrigger interface for draw effects (when card is drawn from deck). Each card type will have its own concrete effect class (e.g., ShuffleEffect, ExplodingKittenTrigger), implementing the Strategy Pattern. This allows new card types to be added by simply creating new strategy classes without modifying GameUI or existing card implementations.

- For shuffle card, it uses a shuffler strategy for shuffle function. Currently, Deck.shuffleDeck() has the Fisher-Yates algorithm hardcoded directly in the method, violating Open/Closed Principle. If we want different shuffle implementations , we must modify the Deck class. To enable algorithm flexibility and support future swap of shuffle implementations at runtime, we apply the Strategy Pattern with a ShuffleStrategy interface. Concrete implementations like FisherYatesShuffle or other implementation in future can be injected into ShuffleEffect, allowing us to change shuffle behavior without modifying the Deck class. This also improves testability - we can use a predictable shuffle strategy for testing instead of random shuffling.

- For exploding kitten card, it has a draw effect which triggers defuse checking and kill effects for whoever draws the card. This complex logic in GameUI.playExplodingKitten() mixes UI prompts with game logic, violating Single Responsibility Principle. For cards with special draw behavior (exploding kitten, imploding kitten, streaking kitten), we introduce the DrawTrigger interface that implements the Strategy Pattern. Each bomb card gets its own trigger class (ExplodingKittenTrigger, ImplodingKittenTrigger) that encapsulates all draw-time behavior. This separates "use effects" (playing cards) from "draw triggers" (drawing cards) which means not all cards need both behaviors. We can directly decouple the use effect and draw effect. Regular cards use NormalDrawTrigger (just add to hand), while bomb cards have complex triggers. This design makes it easy to add new bomb types without modifying existing draw logic.

- For NOPE implementation, we use the Decorator Pattern to wrap effects that require NOPE checking. Currently, GameUI has checkAllPlayersForNope() method duplicated in many places, which introduces lots of code duplication and potential dependency (make debug hard). Every NOPEable card (Shuffle, Attack, See the Future, etc.) must manually call this method, and NOPE chain logic (NOPE a NOPE) is copy-pasted. We introduce NOPEInterceptor class that implements CardEffect interface and wraps another CardEffect. The interceptor's execute() method first checks for NOPE responses (implementing Chain of Responsibility for NOPE chains), and only calls the wrapped effect's execute() if not cancelled. This decorator is transparent and it maintains the exact same interface as CardEffect (like what we do in lecture). The factory decides which effects get wrapped: cards affecting others (Shuffle, Attack) are wrapped with NOPEInterceptor, while personal cards (Skip) are not. This eliminates code duplication, centralizes NOPE logic, and follows open/Closed Principle - adding NOPE capability to a card just requires wrapping it, no modification to the card's effect class.

- For card initialization, we use Factory Pattern to map card types to their concrete effects and draw triggers. The CardEffectFactory maintains registries Map<CardType, CardEffect> and Map<CardType, DrawTrigger> that map each CardType enum to its appropriate strategy implementations. During registration, the factory decides which effects need NOPEInterceptor wrapping based on game rules (affects other players = wrap, personal benefit = don't wrap). The CardFactory uses CardEffectFactory to create complete Card objects with both useEffect and drawTrigger properly configured. This centralized creation follows Single Responsibility Principle (factory's job is only creation) and Open/Closed Principle (adding new cards means adding factory registrations, not modifying existing card classes). The factory also enables easy configuration changes - changing which cards can be NOPEd only requires modifying one line in factory registration, not need to modify the GameUI code.

- For EffectContext, we try to enable uniform interface across all card effects. Each card needs different dependencies (ShuffleEffect needs deck and input, NOPEInterceptor needs all players, SeeTheFutureEffect needs only deck and output), but we require execute(EffectContext context) signature for all effects. Without this uniform interface, design patterns break: Factory cannot create effects generically, Decorator cannot wrap effects uniformly, and polymorphism fails. The trade-off is that EffectContext violates the least knowledge principle - effects get access to more objects than they individually need (ShuffleEffect can access players even though it only uses deck). We accept this trade-off because the benefits outweigh the risks: uniform interface enables Factory and Decorator patterns, GameUI has single code path for all effects, and adding new effects doesn't require changing existing code. We control the risk through code reviews for misuse, unit tests for verifying effects only touch what they should.

- For EffectResult and DrawResult, we design explicit result objects. EffectResult and DrawResult provide immutable return values that describe what happened, eliminating the need to check global game state after effects execute. Effects are commands (have side effects on game state) but return query objects (no side effects, just data about what occurred). Factory methods like EffectResult.success(), EffectResult.cancelled(), DrawResult.exploded() make intent clear and enable fluent creation. These result objects solve multiple problems: no exception-based control flow for normal game events, no void methods requiring state inspection afterward, improved testability (assert on result properties directly), and type safety (DrawResult has shouldKeepCard() for draw context, EffectResult has isCancelled() for NOPE handling). This aligns with Information Hiding Principle - callers don't need to understand internal effect implementation, just inspect the returned result object. 