# Analysis of change in design

- We want to break the card rules into pluggable effects, so we can add new card with specific use effect and draw effect (like the exploding kitten), which is according to the **Open/Closed Principle**. Currently, GameUI contains a massive switch statement (150+ lines in startTurn() method) that hardcodes behavior for every card type. When adding new cards, we must modify this existing code, violating OCP. Additionally, the card effect logic is entirely embedded in GameUI, which demonstrates **Single Responsibility Principle** violation - the GameUI module takes responsibility for both UI interaction AND card effect behavior definition. This tight coupling makes the system rigid, hard to test (cannot test card effects without UI), and difficult to extend. To solve this, we introduce **CardEffect** interface for card use effects (when player plays the card) and **DrawTrigger** interface for draw effects (when card is drawn from deck). Each card type will have its own concrete effect class (e.g., ShuffleEffect, AttackEffect, ExplodingKittenTrigger), implementing the Strategy Pattern. This allows new card types to be added by simply creating new strategy classes without modifying GameUI or existing card implementations.

- For shuffle card, it uses a shuffler strategy for shuffle function. Currently, Deck.shuffleDeck() has the Fisher-Yates algorithm hardcoded directly in the method, violating **Open/Closed Principle**. If we want different shuffle implementations (e.g., riffle shuffle, pile shuffle for testing), we must modify the Deck class. To enable algorithm flexibility and support future swap of shuffle implementations at runtime, we apply the **Strategy Pattern** with a **ShuffleStrategy** interface. Concrete implementations like FisherYatesShuffle, RiffleShuffle, and PileShuffle can be injected into ShuffleEffect, allowing us to change shuffle behavior without modifying the Deck class. This also improves testability - we can use a predictable shuffle strategy for testing instead of random shuffling.

- For exploding kitten card, it has a draw effect which triggers defuse checking, cursed player handling, streaking kitten interactions, and kill effects for whoever draws the card. This complex 100+ line logic in GameUI.playExplodingKitten() mixes UI prompts with game logic, violating **Single Responsibility Principle**. For cards with special draw behavior (exploding kitten, imploding kitten, streaking kitten), we introduce the **DrawTrigger** interface that implements the Strategy Pattern. Each bomb card gets its own trigger class (ExplodingKittenTrigger, ImplodingKittenTrigger) that encapsulates all draw-time behavior. This separates "use effects" (playing cards) from "draw triggers" (drawing cards), following **Interface Segregation Principle** - not all cards need both behaviors. Regular cards use NormalDrawTrigger (just add to hand), while bomb cards have complex triggers. This design makes it easy to add new bomb types without modifying existing draw logic.

- For NOPE implementation, we use the **Decorator Pattern** to wrap effects that require NOPE checking. Currently, GameUI has checkAllPlayersForNope() method duplicated in 10+ places, violating **DRY Principle**. Every NOPEable card (Shuffle, Attack, See the Future, etc.) must manually call this method, and NOPE chain logic (NOPE a NOPE) is copy-pasted. We introduce **NOPEInterceptor** class that implements CardEffect interface and wraps another CardEffect. The interceptor's execute() method first checks for NOPE responses (implementing Chain of Responsibility for NOPE chains), and only calls the wrapped effect's execute() if not cancelled. This decorator is transparent - it maintains the exact same interface as CardEffect, so client code (GameUI) cannot tell if an effect is wrapped or not. The factory decides which effects get wrapped: cards affecting others (Shuffle, Attack) are wrapped with NOPEInterceptor, while personal cards (Skip) are not. This eliminates code duplication, centralizes NOPE logic, and follows **Open/Closed Principle** - adding NOPE capability to a card just requires wrapping it, no modification to the card's effect class.

- For card initialization, we use **Factory Pattern** to map card types to their concrete effects and draw triggers. The **CardEffectFactory** maintains registries (Map<CardType, CardEffect> and Map<CardType, DrawTrigger>) that map each CardType enum to its appropriate strategy implementations. During registration, the factory decides which effects need NOPEInterceptor wrapping based on game rules (affects other players = wrap, personal benefit = don't wrap). The **CardFactory** uses CardEffectFactory to create complete Card objects with both useEffect and drawTrigger properly configured. This centralized creation follows **Single Responsibility Principle** (factory's job is only creation) and **Open/Closed Principle** (adding new cards means adding factory registrations, not modifying existing card classes). The factory also enables easy configuration changes - changing which cards can be NOPEd only requires modifying one line in factory registration, not hunting through 2000 lines of GameUI code.

- For card effect result and context, we design dedicated classes following the **Parameter Object Pattern** and **Result Object Pattern**. **EffectContext** bundles all data needed for effect execution (game, currentPlayer, targetPlayer, userInput, deck) into a single object, solving the problem of methods with 6+ parameters that violate **Law of Demeter**. Context provides controlled access to game state without exposing implementation details, supporting **Dependency Inversion Principle** - effects depend on EffectContext abstraction, not concrete Game/Player implementations. This makes testing easy with MockEffectContext. **EffectResult** and **DrawResult** provide explicit, immutable return values that describe what happened, eliminating the need to check global game state after effects execute. They follow **Command Query Separation** - effects are commands (have side effects) but return query objects (no side effects, just data). Factory methods like EffectResult.success(), EffectResult.cancelled(), DrawResult.exploded() make intent clear. These result objects solve multiple problems: no exception-based control flow, no void methods that require state checking, improved testability (assert on result properties), and type safety (DrawResult has shouldKeepCard() while EffectResult has isCancelled() - each has exactly what it needs per **Interface Segregation Principle**).