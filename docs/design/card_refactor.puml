@startuml Card Refactoring Design

title Card System Refactoring - Strategy and Decorator Patterns

package "Domain Layer" {
    
    class Card {
        - cardType: CardType
        - isMarked: boolean
        - isFacedUp: boolean
        - useEffect: CardEffect
        - drawTrigger: DrawTrigger
        + Card(cardType: CardType, useEffect: CardEffect, drawTrigger: DrawTrigger)
        + getCardType(): CardType
        + executeUseEffect(context: EffectContext): EffectResult
        + executeDrawTrigger(context: EffectContext): DrawResult
        + markCard(): void
        + setFacedUp(): void
        + checkIfMarked(): boolean
        + checkIfFacedUp(): boolean
    }
    
    enum CardType {
        NOPE
        DEFUSE
        ATTACK
        SHUFFLE
        SKIP
        SEE_THE_FUTURE
        EXPLODING_KITTEN
        STREAKING_KITTEN
        IMPLODING_KITTEN
        REVERSE
        CATOMIC_BOMB
    }
    
    class EffectContext {
        - game: Game
        - currentPlayer: Player
        - allPlayers: Player[]
        - input: InputProvider
        - output: OutputProvider
        - targetPlayer: Player
        + EffectContext(game: Game, currentPlayer: Player, allPlayers: Player[], input: InputProvider, output: OutputProvider)
        + getGame(): Game
        + getCurrentPlayer(): Player
        + getAllPlayers(): Player[]
        + getDeck(): Deck
        + getInput(): InputProvider
        + getOutput(): OutputProvider
        + getTargetPlayer(): Player
        + setTargetPlayer(player: Player): void
    }
    
    class EffectResult {
        - success: boolean
        - endsTurn: boolean
        - message: String
        - cancelled: boolean
        + isSuccess(): boolean
        + shouldEndTurn(): boolean
        + getMessage(): String
        + isCancelled(): boolean
    }
    
    class DrawResult {
        - survived: boolean
        - message: String
        - shouldKeepCard: boolean
        + didSurvive(): boolean
        + getMessage(): String
        + shouldKeepCard(): boolean
    }
}

package "Card Effect Strategies" {
    
    interface CardEffect {
        + execute(context: EffectContext): EffectResult
        + canExecute(context: EffectContext): boolean
    }
    
    interface DrawTrigger {
        + onDraw(context: EffectContext): DrawResult
    }
    
    class ShuffleEffect {
        - shuffleStrategy: ShuffleStrategy
        + ShuffleEffect(shuffleStrategy: ShuffleStrategy)
        + execute(context: EffectContext): EffectResult
        + canExecute(context: EffectContext): boolean
    }
    
    class SeeTheFutureEffect {
        - cardsToReveal: int
        + SeeTheFutureEffect(cardsToReveal: int)
        + execute(context: EffectContext): EffectResult
        + canExecute(context: EffectContext): boolean
    }
    
    class AlterTheFutureEffect {
        - cardsToAlter: int
        + AlterTheFutureEffect(cardsToAlter: int)
        + execute(context: EffectContext): EffectResult
        + canExecute(context: EffectContext): boolean
    }
    
    class AttackEffect {
        - targeted: boolean
        + AttackEffect(targeted: boolean)
        + execute(context: EffectContext): EffectResult
        + canExecute(context: EffectContext): boolean
    }
    
    class SkipEffect {
        - superSkip: boolean
        + SkipEffect(superSkip: boolean)
        + execute(context: EffectContext): EffectResult
        + canExecute(context: EffectContext): boolean
    }
    
    class ReverseEffect {
        + execute(context: EffectContext): EffectResult
        + canExecute(context: EffectContext): boolean
    }
    
    class CatomicBombEffect {
        + execute(context: EffectContext): EffectResult
        + canExecute(context: EffectContext): boolean
    }
    
    class NoEffect {
        + execute(context: EffectContext): EffectResult
        + canExecute(context: EffectContext): boolean
    }
    
    class NOPEInterceptor {
        - wrappedEffect: CardEffect
        - requiresNOPECheck: boolean
        + NOPEInterceptor(wrappedEffect: CardEffect, requiresNOPECheck: boolean)
        + execute(context: EffectContext): EffectResult
        + canExecute(context: EffectContext): boolean
        - checkForNOPE(context: EffectContext, playedByPlayer: Player): boolean
        - findNOPECard(player: Player): int
    }
}

package "Draw Triggers" {
    
    class ExplodingKittenTrigger {
        + onDraw(context: EffectContext): DrawResult
    }
    
    class ImplodingKittenTrigger {
        + onDraw(context: EffectContext): DrawResult
    }
    
    class NormalDrawTrigger {
        + onDraw(context: EffectContext): DrawResult
    }
    
    class StreakingKittenTrigger {
        + onDraw(context: EffectContext): DrawResult
    }
}

package "Shuffle Strategies" {
    
    interface ShuffleStrategy {
        + shuffle(deck: Deck): void
    }
    
    class FisherYatesShuffle {
        + shuffle(deck: Deck): void
    }
    
    class RiffleShuffle {
        + shuffle(deck: Deck): void
    }
    
    class PileShuffle {
        - numberOfPiles: int
        + PileShuffle(numberOfPiles: int)
        + shuffle(deck: Deck): void
    }
}

package "Combo System" {
    
    interface ComboEffect {
        + execute(context: EffectContext): EffectResult
        + getRequiredCardCount(): int
        + acceptsFeralCat(): boolean
    }
    
    class TwoOfAKindCombo {
        + execute(context: EffectContext): EffectResult
        + getRequiredCardCount(): int
        + acceptsFeralCat(): boolean
    }
    
    class ThreeOfAKindCombo {
        + execute(context: EffectContext): EffectResult
        + getRequiredCardCount(): int
        + acceptsFeralCat(): boolean
    }
    
    class ComboValidator {
        + validateCombo(player: Player, cardType: CardType, count: int, feralCats: int): boolean
        + removeCardsForCombo(player: Player, cardType: CardType, count: int, feralCats: int): void
    }
}

package "Factory Pattern" {
    
    class CardEffectFactory {
        - effectRegistry: Map<CardType, CardEffect>
        - shuffleStrategy: ShuffleStrategy
        + CardEffectFactory()
        + getEffect(cardType: CardType): CardEffect
        + getTrigger(cardType: CardType): DrawTrigger
        + hasEffect(cardType: CardType): boolean
        + hasTrigger(cardType: CardType): boolean
        - registerEffects(): void
    }
    
    class CardFactory {
        - effectFactory: CardEffectFactory
        + CardFactory(effectFactory: CardEffectFactory)
        + createCard(cardType: CardType): Card
    }
}

package "UI Layer - Input/Output" {
    
    interface InputProvider {
        + readInteger(message: String, min: int, max: int): int
        + readYesNo(message: String): boolean
    }
    
    interface OutputProvider {
        + display(message: String): void
    }
    
    class ConsoleInput {
        - scanner: Scanner
        + ConsoleInput(scanner: Scanner)
        + readInteger(message: String, min: int, max: int): int
        + readYesNo(message: String): boolean
    }
    
    class ConsoleOutput {
        + display(message: String): void
    }
}


' Card Effect Hierarchy
CardEffect ..> EffectContext
CardEffect ..> EffectResult
CardEffect <|.. ShuffleEffect
CardEffect <|.. SeeTheFutureEffect
CardEffect <|.. AlterTheFutureEffect
CardEffect <|.. AttackEffect
CardEffect <|.. SkipEffect
CardEffect <|.. ReverseEffect
CardEffect <|.. CatomicBombEffect
CardEffect <|.. NoEffect
CardEffect <|.. NOPEInterceptor
NOPEInterceptor --> CardEffect

' Draw Trigger Hierarchy
DrawTrigger ..> EffectContext
DrawTrigger ..> DrawResult
DrawTrigger <|.. ExplodingKittenTrigger
DrawTrigger <|.. ImplodingKittenTrigger
DrawTrigger <|.. NormalDrawTrigger
DrawTrigger <|.. StreakingKittenTrigger

' Shuffle Strategy Hierarchy
ShuffleStrategy <|.. FisherYatesShuffle
ShuffleStrategy <|.. RiffleShuffle
ShuffleStrategy <|.. PileShuffle
ShuffleEffect --> ShuffleStrategy

' Combo Effect Hierarchy
ComboEffect <|.. TwoOfAKindCombo
ComboEffect <|.. ThreeOfAKindCombo
TwoOfAKindCombo ..> ComboValidator
ThreeOfAKindCombo ..> ComboValidator

' Input/Output Layer Hierarchy (ui/io package)
InputProvider <|.. ConsoleInput
OutputProvider <|.. ConsoleOutput
EffectContext --> InputProvider
EffectContext --> OutputProvider

' Card Relationships
Card --> CardType
Card --> CardEffect
Card --> DrawTrigger

' Factory Relationships
CardEffectFactory ..> CardEffect
CardEffectFactory ..> DrawTrigger
CardEffectFactory ..> NOPEInterceptor
CardFactory ..> Card
CardFactory --> CardEffectFactory

note right of NOPEInterceptor
  Decorator Pattern: Wraps CardEffect
  Maintains identical interface
  Checks for NOPE before executing
  Private shouldCancelDueToNOPE method
  Implements Chain of Responsibility
end note

note right of CardEffectFactory
  Factory decides which effects
  need NOPEInterceptor wrapping
  Cards affecting others: wrapped
  Personal benefit cards: not wrapped
end note


@enduml